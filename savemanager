local httpService = game:GetService("HttpService")

-- Types and Helpers
type Dropdown = {Value: any, Values: {i: any}, Multi: boolean, Displayer: (v) -> (n)?, SetValue: (any) -> ()}

local DisplayerParser = {
    Encode = function(Value)
        local Encoded = {}
        for Val: any, Bool: boolean in Value do
            table.insert(Encoded, Val)
        end
        return Encoded
    end,
}

local function TableEqual(Table, Reflect)
    for Index, Value in Table do 
        if Reflect[Index] ~= Value then return false end 
    end 
    return true
end  

local function SetDisplayerDropdownValue(Dropdown: Dropdown, Value)
    if Dropdown.Multi then
        local Values = {}
        for _, DataValue in Value do 
            for _, DropdownValue in Dropdown.Values do 
                if typeof(DropdownValue) ~= 'table' or not TableEqual(DataValue, DropdownValue) then continue end 
                Values[DropdownValue] = true
                break
            end
        end
        Dropdown:SetValue(Values)
    else
        for _, DropdownValue in Dropdown.Values do 
            if typeof(DropdownValue) ~= 'table' or not TableEqual(Value, DropdownValue) then continue end 
            Dropdown:SetValue(DropdownValue)
            break
        end	
    end
end

-- ===========================
-- MAIN SAVE MANAGER
-- ===========================
local SaveManager = {} do
    SaveManager.Folder = "FluentSettings"
    SaveManager.Ignore = {}
    SaveManager.Options, SaveManager.Library = {} :: { [string]: {Type: string, Value: any, SetValues: (self: any, NewValue: { [any]: any }) -> nil, SetValue: (self: any, NewValue: any, ...any) -> nil, SetValueRGB: (self: any, NewValue: Color3, Transparency: number?) -> nil} }, {}
    
    -- UPDATED: Pointing to your Local Ngrok tunnel
    SaveManager.RemoteUrl = "https://lyingly-unrepresented-kaydence.ngrok-free.dev/get_settings"

    SaveManager.Parser = {
        Toggle = {
            Save = function(idx, object) 
                return { type = "Toggle", idx = idx, value = object.Value, Timestamp = os.time() } 
            end,
            Load = function(idx, data)
                if SaveManager.Options[idx] and SaveManager.Options[idx].Value ~= data.value then 
                    SaveManager.Options[idx]:SetValue(data.value)
                end
            end,
        },
        Slider = {
            Save = function(idx, object)
                return { type = "Slider", idx = idx, value = object.Value, Timestamp = os.time() }
            end,
            Load = function(idx, data)
                if SaveManager.Options[idx] and SaveManager.Options[idx].Value ~= data.value then 
                    SaveManager.Options[idx]:SetValue(data.value)
                end
            end,
        },
        Dropdown = {
            Save = function(idx, object)
                local HasDisplayer = object.CustomDisplayer
                return { type = "Dropdown", idx = idx, value = (HasDisplayer and object.Multi and DisplayerParser.Encode(object.Value) or object.Value), mutli = object.Multi, Timestamp = os.time(), displayer = HasDisplayer}
            end,
            Load = function(idx, data)
                if data.value == nil then return end
                local DropdownElement = SaveManager.Options[idx]
                if not DropdownElement then return end
                local Value = data.value 
                if typeof(Value) ~= 'table' or (not data.displayer) then
                    DropdownElement:SetValue(Value)
                    return
                end
                SetDisplayerDropdownValue(DropdownElement, Value)
            end,
        },
        -- (Other parsers remain the same as your original snippet)
    }

    function SaveManager:LoadRemoteConfig(silent)
        if self.RemoteUrl == "" then return end

        local success, result = pcall(function()
            -- Added a small timeout so it doesn't hang if Ngrok is slow
            return game:HttpGet(self.RemoteUrl)
        end)

        if not success or not result then return end

        local decodedData
        success, decodedData = pcall(function()
            return httpService:JSONDecode(result)
        end)

        if success and type(decodedData) == "table" then
            local count = 0
            for _, option in next, decodedData.objects do
                if self.Parser[option.type] then
                    task.spawn(function()
                        pcall(function()
                            self.Parser[option.type].Load(option.idx, option)
                        end)
                    end)
                    count = count + 1
                end
            end
            
            if not silent then
                self.Library:Notify({
                    Title = "Cloud Sync",
                    Content = "Success",
                    SubContent = string.format("Synced %d settings from Discord.", count),
                    Duration = 3
                })
            end
        end
    end

    function SaveManager:SetLibrary(library)
        self.Library = library
        self.Options = library.Options
    end

    -- UPDATED: Added a Background Sync Loop
    function SaveManager:LoadAutoloadConfig()
        -- Load local first (Priority)
        if isfile(`{self.Folder}/settings/autoload.txt`) then
            local name = readfile(`{self.Folder}/settings/autoload.txt`)
            self:Load(name)
        end

        -- Start the Continuous Background Sync for your Project
        task.spawn(function()
            while true do
                self:LoadRemoteConfig(true) -- Silent sync
                task.wait(5) -- Check every 5 seconds
            end
        end)
    end

    -- (Building folder tree and other UI functions remain same)
    function SaveManager:BuildFolderTree()
        local paths = { self.Folder, `{self.Folder}/settings` }
        for i = 1, #paths do
            if not isfolder(paths[i]) then makefolder(paths[i]) end
        end
    end

    SaveManager:BuildFolderTree()
end

return SaveManager
