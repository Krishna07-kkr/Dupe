local httpService = game:GetService("HttpService")

-- Types and Helpers
type Dropdown = {Value: any, Values: {i: any}, Multi: boolean, Displayer: (v) -> (n)?, SetValue: (any) -> ()}

local DisplayerParser = {
    Encode = function(Value)
        local Encoded = {}
        for Val: any, Bool: boolean in Value do
            table.insert(Encoded, Val)
        end
        return Encoded
    end,
}

local function TableEqual(Table, Reflect)
    for Index, Value in Table do 
        if Reflect[Index] ~= Value then return false end 
    end 
    return true
end  

local function SetDisplayerDropdownValue(Dropdown: Dropdown, Value)
    if Dropdown.Multi then
        local Values = {}
        for _, DataValue in Value do 
            for _, DropdownValue in Dropdown.Values do 
                if typeof(DropdownValue) ~= 'table' or not TableEqual(DataValue, DropdownValue) then continue end 
                Values[DropdownValue] = true
                break
            end
        end
        Dropdown:SetValue(Values)
    else
        for _, DropdownValue in Dropdown.Values do 
            if typeof(DropdownValue) ~= 'table' or not TableEqual(Value, DropdownValue) then continue end 
            Dropdown:SetValue(DropdownValue)
            break
        end	
    end
end

-- ===========================
-- MAIN SAVE MANAGER
-- ===========================
local SaveManager = {} do
    SaveManager.Folder = "FluentSettings"
    SaveManager.Ignore = {}
    SaveManager.Options, SaveManager.Library = {} :: { [string]: {Type: string, Value: any, SetValues: (self: any, NewValue: { [any]: any }) -> nil, SetValue: (self: any, NewValue: any, ...any) -> nil, SetValueRGB: (self: any, NewValue: Color3, Transparency: number?) -> nil} }, {}
    
    -- YOUR LIVE TUNNEL URL
    SaveManager.RemoteUrl = "https://lyingly-unrepresented-kaydence.ngrok-free.dev/get_settings"

    SaveManager.Parser = {
        Toggle = {
            Save = function(idx, object) 
                return { type = "Toggle", idx = idx, value = object.Value, Timestamp = os.time() } 
            end,
            Load = function(idx, data)
                if SaveManager.Options[idx] and SaveManager.Options[idx].Value ~= data.value then 
                    SaveManager.Options[idx]:SetValue(data.value)
                end
            end,
        },
        Slider = {
            Save = function(idx, object)
                return { type = "Slider", idx = idx, value = object.Value, Timestamp = os.time() }
            end,
            Load = function(idx, data)
                if SaveManager.Options[idx] and SaveManager.Options[idx].Value ~= data.value then 
                    SaveManager.Options[idx]:SetValue(data.value)
                end
            end,
        },
        Dropdown = {
            Save = function(idx, object)
                local HasDisplayer = object.CustomDisplayer
                return { type = "Dropdown", idx = idx, value = (HasDisplayer and object.Multi and DisplayerParser.Encode(object.Value) or object.Value), mutli = object.Multi, Timestamp = os.time(), displayer = HasDisplayer}
            end,
            Load = function(idx, data)
                if data.value == nil then return end
                local DropdownElement = SaveManager.Options[idx]
                if not DropdownElement then return end
                local Value = data.value 
                if typeof(Value) ~= 'table' or (not data.displayer) then
                    DropdownElement:SetValue(Value)
                    return
                end
                SetDisplayerDropdownValue(DropdownElement, Value)
            end,
        },
        Colorpicker = {
            Save = function(idx, object)
                return { type = "Colorpicker", idx = idx, value = object.Value:ToHex(), transparency = object.Transparency, Timestamp = os.time() }
            end,
            Load = function(idx, data)
                if SaveManager.Options[idx] then 
                    SaveManager.Options[idx]:SetValueRGB(Color3.fromHex(data.value), data.transparency)
                end
            end,
        },
        Keybind = {
            Save = function(idx, object)
                return { type = "Keybind", idx = idx, mode = object.Mode, key = object.Value, Timestamp = os.time() }
            end,
            Load = function(idx, data)
                if SaveManager.Options[idx] then 
                    SaveManager.Options[idx]:SetValue(data.key, data.mode)
                end
            end,
        },
        Input = {
            Save = function(idx, object)
                return { type = "Input", idx = idx, text = object.Value, Timestamp = os.time() }
            end,
            Load = function(idx, data)
                if SaveManager.Options[idx] and type(data.text) == "string" then
                    SaveManager.Options[idx]:SetValue(data.text)
                end
            end,
        },
    }

    function SaveManager:LoadRemoteConfig(silent)
        if self.RemoteUrl == "" then return end

        local success, result = pcall(function()
            return game:HttpGet(self.RemoteUrl)
        end)

        if not success or not result then return end

        local success2, decodedData = pcall(function()
            return httpService:JSONDecode(result)
        end)

        if success2 and type(decodedData) == "table" then
            for _, option in next, decodedData.objects do
                if self.Parser[option.type] then
                    pcall(function()
                        self.Parser[option.type].Load(option.idx, option)
                    end)
                end
            end
        end
    end

    function SaveManager:SetLibrary(library)
        self.Library = library
        self.Options = library.Options
    end

    function SaveManager:LoadAutoloadConfig()
        if isfile(`{self.Folder}/settings/autoload.txt`) then
            local name = readfile(`{self.Folder}/settings/autoload.txt`)
            self:Load(name)
        end

        -- Start the Continuous Background Sync (Checks every 5 seconds)
        task.spawn(function()
            while true do
                self:LoadRemoteConfig(true)
                task.wait(5)
            end
        end)
    end

    function SaveManager:BuildFolderTree()
        local paths = { self.Folder, `{self.Folder}/settings` }
        for i = 1, #paths do
            if not isfolder(paths[i]) then makefolder(paths[i]) end
        end
    end

    SaveManager:BuildFolderTree()
end

return SaveManager
